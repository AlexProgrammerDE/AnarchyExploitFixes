package me.moomoo.anarchyexploitfixes.folia;

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import com.google.common.util.concurrent.AtomicDouble;
import io.papermc.paper.threadedregions.*;
import io.papermc.paper.threadedregions.scheduler.EntityScheduler;
import me.moomoo.anarchyexploitfixes.common.TPSCache;
import org.bukkit.Location;
import org.bukkit.Server;
import org.bukkit.World;
import org.bukkit.plugin.java.JavaPlugin;

import java.time.Duration;

public class FoliaTPSCache implements TPSCache {
    private final JavaPlugin plugin;
    private final Server server;
    private final Cache<TickRegionScheduler.RegionScheduleHandle, Double> cached_tps;

    public FoliaTPSCache(JavaPlugin plugin, long checkDelayMillis) {
        this.plugin = plugin;
        this.server = plugin.getServer();
        this.cached_tps = Caffeine.newBuilder().expireAfterWrite(Duration.ofMillis(checkDelayMillis)).build();
    }

    @Override
    public double getGlobalTPS() {
        // Get region handle and check if there is already a cached tps for it
        final TickRegionScheduler.RegionScheduleHandle
                regionHandle = RegionizedServer.getGlobalTickData();
        Double tps = this.cached_tps.getIfPresent(regionHandle);
        if (tps == null) {
            // If nothing is cached yet, get tps and add to cache
            tps = regionHandle.getTickReport15s(System.nanoTime()).tpsData().segmentAll().average();
            this.cached_tps.put(regionHandle, tps);
        }
        return tps;
    }

    @Override
    public double getTPS(Location location) {
        if (location == null) return getGlobalTPS();
        return getTPS(location.getWorld(), location.getBlockX() >> 4, location.getBlockZ() >> 4);
    }

    @Override
    public double getTPS(World world, int chunkX, int chunkZ) {
        if (world == null) return getGlobalTPS();
        // Use AtomicDouble because we need a value from the lambda
        // Init with 20 (perfect) tps, so we have a valid and safe fallback value
        AtomicDouble atomic_tps = new AtomicDouble(20.0);
        // Update atomic double via region scheduler execute method so usage of TickRegionScheduler.getCurrentRegion()
        // happens faster and on the thread of the region that owns the location.
        this.server.getRegionScheduler().execute(this.plugin, world, chunkX, chunkZ, () -> {
            // Get the potential separate region that owns the location
            final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData>
                    currentRegion = TickRegionScheduler.getCurrentRegion();
            // If not happening on a separate region, it must mean we're on the main region
            if (currentRegion == null) {
                atomic_tps.set(getGlobalTPS());
                return;
            }
            // Get region handle and check if there is already a cached tps for it
            final TickRegionScheduler.RegionScheduleHandle
                    regionHandle = currentRegion.getData().getRegionSchedulingHandle();
            Double tps = this.cached_tps.getIfPresent(regionHandle);
            if (tps == null) {
                // If nothing is cached yet, get tps and add to cache
                tps = regionHandle.getTickReport15s(System.nanoTime()).tpsData().segmentAll().average();
                this.cached_tps.put(regionHandle, tps);
            }
            atomic_tps.set(tps);
        });
        return atomic_tps.get();
    }
}
