package me.moomoo.anarchyexploitfixes.modules.lagpreventions;

import com.cryptomorin.xseries.XMaterial;
import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import me.moomoo.anarchyexploitfixes.AnarchyExploitFixes;
import me.moomoo.anarchyexploitfixes.config.Config;
import me.moomoo.anarchyexploitfixes.modules.AnarchyExploitFixesModule;
import me.moomoo.anarchyexploitfixes.utils.LogUtil;
import org.bukkit.Chunk;
import org.bukkit.Material;
import org.bukkit.block.Block;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockFromToEvent;

import java.time.Duration;
import java.util.logging.Level;

public class LiquidUpdateLag implements AnarchyExploitFixesModule, Listener {

    private final Cache<Chunk, Integer> liquidSpreadEventCountCache;
    private final Material DRAGON_EGG;
    private final int maxLiquidSpreadEventsPerChunk;
    private final boolean logIsEnabled;

    public LiquidUpdateLag() {
        shouldEnable();
        this.DRAGON_EGG = XMaterial.DRAGON_EGG.parseMaterial();
        Config config = AnarchyExploitFixes.getConfiguration();
        this.maxLiquidSpreadEventsPerChunk = config.getInt("lag-preventions.prevent-liquid-update-lag.max-liquid-events-in-same-chunk-per-time", 1200,
                "Amount of liquid source blocks * sides it can spread to * block spread length");
        this.liquidSpreadEventCountCache = Caffeine.newBuilder().expireAfterWrite(Duration.ofMillis(
                config.getInt("lag-preventions.prevent-liquid-update-lag.time-in-ticks", 100,
                        "Record time after first liquid spread. \nWhen this time runs out, the spread counter resets") * 50L
        )).build();
        this.logIsEnabled = config.getBoolean("lag-preventions.prevent-liquid-update-lag.log", false,
                "very spammy, use for testing only");
    }

    @Override
    public String name() {
        return "prevent-liquid-update-lag";
    }

    @Override
    public String category() {
        return "lag-preventions";
    }

    @Override
    public void enable() {
        AnarchyExploitFixes plugin = AnarchyExploitFixes.getInstance();
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
    }

    @Override
    public boolean shouldEnable() {
        return AnarchyExploitFixes.getConfiguration().getBoolean("lag-preventions.prevent-liquid-update-lag.enable", false);
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    private void onLiquidSpread(BlockFromToEvent event) {
        final Block sourceBlock = event.getBlock();
        if (sourceBlock.getType().equals(DRAGON_EGG)) return; // Event fires only for liquids and the dragon egg

        final Chunk chunk = sourceBlock.getChunk();
        Integer liquidSpreadCount = liquidSpreadEventCountCache.getIfPresent(chunk);

        if (liquidSpreadCount == null) {
            liquidSpreadEventCountCache.put(chunk, 1);
        } else {
            liquidSpreadCount++;
            liquidSpreadEventCountCache.put(chunk, liquidSpreadCount);
            if (liquidSpreadCount > maxLiquidSpreadEventsPerChunk) {
                event.setCancelled(true);
                if (logIsEnabled) LogUtil.moduleLog(Level.INFO, name(),
                        "Cancelled liquid events for chunk x:" + chunk.getX() + ", z:" + chunk.getZ() +
                                "in world: " + chunk.getWorld().getName());
                return;
            }
        }

        if (logIsEnabled) LogUtil.moduleLog(Level.INFO, name(), " Recorded " + liquidSpreadCount +
                " liquid updates in chunk x:" + chunk.getX() + ", z:" + chunk.getZ() + ", world: " + chunk.getWorld().getName());
    }
}